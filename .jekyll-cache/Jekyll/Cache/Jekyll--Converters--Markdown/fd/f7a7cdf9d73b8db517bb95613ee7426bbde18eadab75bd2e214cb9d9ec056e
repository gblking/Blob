I"2<h3 id="vue3-的改变">Vue3 的改变</h3>

<p><strong>1. 性能提升</strong></p>

<ul>
  <li>打包大小减少 41%</li>
  <li>初次渲染快 55%，更新渲染快 133%</li>
  <li>内存减少 54%
……</li>
</ul>

<p><strong>2. 源码升级</strong></p>

<ul>
  <li>使用 Proxy 代替 defineProperty 实现响应式</li>
  <li>重写虚拟 DOM 的实现和 Tree-Shaking<br />
……</li>
</ul>

<p><strong>3. 拥抱 TypeScript</strong></p>

<ul>
  <li>Vue3 可以更好的支持 TypeScript</li>
</ul>

<p><strong>4. 新特性</strong></p>

<ol>
  <li>
    <p>Composition API (组合 API)</p>

    <ul>
      <li>setup 配置</li>
      <li>ref 与 reactive</li>
      <li>watch 与 inject<br />
……</li>
    </ul>
  </li>
  <li>
    <p>新的内置组件</p>

    <ul>
      <li>Fragment</li>
      <li>Teleport</li>
      <li>Suspense</li>
    </ul>
  </li>
  <li>
    <p>其他改变</p>
    <ul>
      <li>新的生命周期钩子</li>
      <li>data 选项应始终被声明为一个函数</li>
      <li>移除 keyCode 支持作为 v-on 的修饰符<br />
……</li>
    </ul>
  </li>
</ol>

<h3 id="创建-vue30-工程">创建 Vue3.0 工程</h3>

<ol>
  <li>
    <p>使用 vue-cli 创建</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span>
<span class="nx">vue</span> <span class="o">--</span><span class="nx">version</span>
<span class="c1">// 安装或者升级你的@vue/cli</span>
<span class="nx">npm</span> <span class="nx">install</span> <span class="o">-</span><span class="nx">g</span> <span class="p">@</span><span class="nd">vue</span><span class="sr">/cl</span><span class="err">i
</span><span class="c1">// 创建</span>
<span class="nx">vue</span> <span class="nx">create</span> <span class="nx">vue_test</span>
<span class="c1">// 启动</span>
<span class="nx">cd</span> <span class="nx">vue_test</span>
<span class="nx">npm</span> <span class="nx">run</span> <span class="nx">serve</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>使用 vite 创建<br />
 <a href="https://v3.cn.vuejs.org/guide/installation.html#vite">官方文档</a><br />
 <a href="https://vitejs.cn">vite 官网</a></p>

    <p>vite - 新一代前端构建工具</p>

    <p>优势如下：</p>

    <ul>
      <li>开发环境中，无需打包操作，可快速的冷启动</li>
      <li>轻量快速的热重载(HMR)</li>
      <li>真正的按需编译，不再等待整个应用编译完成</li>
    </ul>

    <p>传统构建与 vite 构建对比图：<br />
 传统构建<br />
 <img src="http://localhost:4001/Blob/assets/images/post/20211108/01.webp" alt="传统构建" /><br />
 vite 构建<br />
 <img src="http://localhost:4001/Blob/assets/images/post/20211108/02.webp" alt="vite构建" /></p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建工程</span>
<span class="nx">npm</span> <span class="nx">init</span> <span class="nx">vite</span><span class="o">-</span><span class="nx">app</span> <span class="o">&lt;</span><span class="nx">project</span><span class="o">-</span><span class="nx">name</span><span class="o">&gt;</span>
<span class="c1">// 进入工程目录</span>
<span class="nx">cd</span> <span class="o">&lt;</span><span class="nx">project</span><span class="o">-</span><span class="nx">name</span><span class="o">&gt;</span>
<span class="c1">// 安装依赖</span>
<span class="nx">npm</span> <span class="nx">install</span>
<span class="c1">// 运行</span>
<span class="nx">npm</span> <span class="nx">run</span> <span class="nx">dev</span>
</code></pre></div>    </div>

    <h3 id="常用-composition-api">常用 Composition API</h3>

    <h4 id="setup">setup</h4>

    <ol>
      <li>Vue3.0 中一个新的配置项，值为一个函数</li>
      <li>setup 是所有 Composition API（组合 API） “ 表演的舞台 ”</li>
      <li>组件中所用到的：数据、方法等等，均要配置在 setup 中</li>
      <li>
        <p>setup 函数的两种返回值：</p>

        <ul>
          <li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
          <li>若返回一个渲染函数：则可以自定义渲染内容。（了解）</li>
        </ul>
      </li>
      <li>注意点：
        <ul>
          <li>尽量不要与 Vue2.x 配置混用
            <ul>
              <li>Vue2.x 配置（data、methos、computed…）中可以访问到 setup 中的属性、方法。</li>
              <li>但在 setup 中不能访问到 Vue2.x 配置（data、methos、computed…）。</li>
              <li>如果有重名, setup 优先。</li>
            </ul>
          </li>
          <li>setup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）</li>
        </ul>
      </li>
    </ol>

    <h4 id="ref-函数">ref 函数</h4>

    <ol>
      <li>作用: 定义一个响应式的数据</li>
      <li>语法: <code class="language-plaintext highlighter-rouge">const xxx = ref(initValue)</code>
        <ul>
          <li>创建一个包含响应式数据的<strong>引用对象（reference 对象，简称 ref 对象）</strong></li>
          <li>JS 中操作数据： <code class="language-plaintext highlighter-rouge">xxx.value</code></li>
          <li>模板中读取数据: 不需要.value，直接：<code class="language-plaintext highlighter-rouge">&lt;div&gt;&lt;/div&gt;</code></li>
        </ul>
      </li>
      <li>备注：
        <ul>
          <li>接收的数据可以是：基本类型、也可以是对象类型。</li>
          <li>基本类型的数据：响应式依然是靠 <code class="language-plaintext highlighter-rouge">Object.defineProperty()</code>的 <code class="language-plaintext highlighter-rouge">get</code> 与 <code class="language-plaintext highlighter-rouge">set</code> 完成的。</li>
          <li>对象类型的数据：内部“ 求助 ” 了 Vue3.0 中的一个新函数—— <code class="language-plaintext highlighter-rouge">reactive</code> 函数。</li>
        </ul>
      </li>
    </ol>

    <h4 id="reactive-函数">reactive 函数</h4>

    <ul>
      <li>作用: 定义一个<strong>对象类型</strong>的响应式数据（基本类型不要用它，要用 <code class="language-plaintext highlighter-rouge">ref</code> 函数）</li>
      <li>语法：<code class="language-plaintext highlighter-rouge">const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong>代理对象</strong>（Proxy 的实例对象，简称 proxy 对象）</li>
      <li>reactive 定义的响应式数据是“深层次的”。</li>
      <li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
    </ul>

    <h4 id="vue30-中的响应式原理">Vue3.0 中的响应式原理</h4>

    <ul>
      <li>
        <p>实现原理:</p>

        <ul>
          <li>通过 Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>
          <li>通过 Reflect（反射）: 对源对象的属性进行操作。</li>
          <li>
            <p>MDN 文档中描述的 Proxy 与 Reflect：</p>

            <ul>
              <li>
                <p>Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</p>
              </li>
              <li>
                <p>Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</p>
              </li>
            </ul>
          </li>
        </ul>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">// 拦截读取属性值</span>
  <span class="kd">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Reflect</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="c1">// 拦截设置属性值或添加新属性</span>
  <span class="kd">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Reflect</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="c1">// 拦截删除属性</span>
  <span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">});</span>

<span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">tom</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>        </div>

        <h4 id="reactive-对比-ref">reactive 对比 ref</h4>

        <ol>
          <li>从定义数据角度对比：
            <ul>
              <li>ref 用来定义：<strong>基本类型数据</strong></li>
              <li>reactive 用来定义：<strong>对象（或数组）类型数据</strong></li>
              <li>ref 也可以用来定义<strong>对象（或数组）类型数据</strong>, 它内部会自动通过 <code class="language-plaintext highlighter-rouge">reactive</code> 转为<strong>代理对象</strong></li>
            </ul>
          </li>
          <li>从原理角度对比：
            <ul>
              <li>ref 通过 <code class="language-plaintext highlighter-rouge">Object.defineProperty()</code>的 <code class="language-plaintext highlighter-rouge">get</code> 与 <code class="language-plaintext highlighter-rouge">set</code> 来实现响应式（数据劫持）</li>
              <li>reactive 通过使用 <strong>Proxy</strong> 来实现响应式（数据劫持）, 并通过 <strong>Reflect</strong> 操作<strong>源对象</strong>内部的数据</li>
            </ul>
          </li>
          <li>从使用角度对比：
            <ul>
              <li>ref 定义的数据：操作数据需要<code class="language-plaintext highlighter-rouge">.value</code>，读取数据时模板中直接读取<strong>不需要</strong><code class="language-plaintext highlighter-rouge">.value</code></li>
              <li>reactive 定义的数据：操作数据与读取数据：<strong>均不需要</strong><code class="language-plaintext highlighter-rouge">.value</code></li>
            </ul>
          </li>
        </ol>

        <h4 id="setup-注意点">setup 注意点</h4>

        <ol>
          <li>
            <p>执行时机</p>

            <ul>
              <li>在 beforeCreate 之前执行一次，this 是 undefined</li>
            </ul>
          </li>
          <li>
            <p>setup 参数</p>
            <ul>
              <li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
              <li>context：上下文对象
                <ul>
                  <li>attrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 <code class="language-plaintext highlighter-rouge">this.$attrs</code></li>
                  <li>slots: 收到的插槽内容, 相当于 <code class="language-plaintext highlighter-rouge">this.$slots</code></li>
                  <li>emit: 分发自定义事件的函数, 相当于 <code class="language-plaintext highlighter-rouge">this.$emit</code></li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ol>
:ET